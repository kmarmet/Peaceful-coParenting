// Generated by CoffeeScript 2.7.0
var NotificationManager;

import DB from '../../src/database/DB';

import OneSignal from 'react-onesignal';

import Manager from "./manager.js";

export default NotificationManager = {
  lineBreak: '\r\n',
  // Define message templates
  templates: {
    // Template for event tomorrow reminder
    eventIsTomorrowReminder: function(event) {
      return `${event.title} is tomorrow ${Manager.isValid(event.fromTime) ? '@ ' + event.fromTime : ''}`;
    },
    // Template for event in an hour reminder
    eventIsInAnHourReminder: function(event) {
      return `${event.title} is in 1 hour`;
    },
    // Template for event in half hour reminder
    eventIsInHalfHourReminder: function(event) {
      return `${event.title} is in 30 minutes`;
    },
    // Template for update reminder
    updateReminder: function() {
      return 'Visit New Updates in the menu to learn more';
    },
    // Template for swap request decision
    swapRequestApproval: function(request, recipientName) {
      return `Swap Request decision for ${request.startDate} has been APPROVED by ${recipientName}${NotificationManager.lineBreak}${NotificationManager.lineBreak}`;
    },
    swapRequestRejection: function(request, recipientName) {
      return `Swap Request for ${request.startDate} has been REJECTED.${NotificationManager.lineBreak}${NotificationManager.lineBreak} Reason: ${request.reason}. If you would still prefer to proceed with the request, you can communicate with ${recipientName} to come to an agreement on the request.`;
    },
    transferRequestApproval: function(request, recipientName) {
      return `Transfer Change Request decision for ${request.date} has been APPROVED by ${recipientName}${NotificationManager.lineBreak}${NotificationManager.lineBreak}`;
    },
    transferRequestRejection: function(request, recipientName) {
      return `Transfer Change Request for ${request.date} has been REJECTED.${NotificationManager.lineBreak}${NotificationManager.lineBreak} Reason: ${request.reason}. If you would still prefer to proceed with the request, you can communicate with ${recipientName} to come to an agreement on the request.`;
    }
  },
  apiKey: function() {
    if (window.location.href.indexOf("localhost") > -1) {
      return 'os_v2_app_j6desntrnffrplh255adzo5p5dy5bymf5qrexxmauni7ady7m6v5kxspx55zktplqa6un2jfyc6az5yvhaxfkgbtpfjf3siqd2th3ty';
    } else {
      return 'os_v2_app_wjb2emrqojh2re4vwfdvavgfgfpm3s3xxaduhlnuiah2weksujvxpesz4fnbclq7b2dch2k3ixixovlaroxcredbec4ghwac4qpcjbi';
    }
  },
  init: function() {
    window.OneSignalDeferred = window.OneSignalDeferred || [];
    return OneSignalDeferred.push(function() {
      return OneSignal.init({
        appId: NotificationManager.getAppId()
      }).then(function() {
        return OneSignal.User.PushSubscription.addEventListener('change', NotificationManager.eventListener);
      });
    });
  },
  eventListener: function(event) {
    var ref, ref1, userSubscribed;
    userSubscribed = OneSignal.User.PushSubscription.optedIn;
    if (userSubscribed) {
      NotificationManager.subscriptionId = event != null ? (ref = event.current) != null ? ref.id : void 0 : void 0;
      localStorage.setItem("subscriptionId", event != null ? (ref1 = event.current) != null ? ref1.id : void 0 : void 0);
      return setTimeout(function() {
        return window.location.reload();
      }, 2000);
    }
  },
  getUserSubId: async function(currentUser) {
    var existingRecord;
    existingRecord = (await DB.find(DB.tables.notificationSubscribers, ['email', currentUser.email], true));
    return existingRecord.subscriptionId;
  },
  sendNotification: function(title, message, subId) {
    var myHeaders, raw, requestOptions;
    myHeaders = new Headers();
    myHeaders.append("Accept", "application/json");
    myHeaders.append("Content-Type", "application/json");
    myHeaders.append("Authorization", `Basic ${NotificationManager.apiKey()}`);
    raw = JSON.stringify({
      contents: {
        en: message
      },
      headings: {
        en: title
      },
      target_channel: "push",
      isAnyWeb: true,
      enable_frequency_cap: false,
      included_segments: ["All"],
      include_aliases: {
        aliases: [subId]
      },
      app_id: NotificationManager.getAppId()
    });
    requestOptions = {
      method: "POST",
      headers: myHeaders,
      body: raw,
      redirect: "follow"
    };
    return fetch("https://api.onesignal.com/notifications?c=push", requestOptions).then(function(response) {
      return response.text();
    }).then(function(result) {
      return console.log(result);
    }).catch(function(error) {
      return console.error(error);
    });
  },
  //disableNotifications: (id) ->
  //    url = "https://api.onesignal.com/apps/#{NotificationManager.getAppId()}/subscriptions/#{id}"
  //    options =
  //      method: 'DELETE'
  //      headers:
  //        accept: 'application/json'
  getAppId: function() {
    var appId;
    if (window.location.href.indexOf("localhost") > -1) {
      appId = '4f864936-7169-4b17-acfa-ef403cbbafe8';
    } else {
      appId = 'b243a232-3072-4fa8-9395-b1475054c531';
    }
    return appId;
  },
  sendToShareWith: async function(coparentPhones, title, message) {
    var i, len, phone, results, subId;
    results = [];
    for (i = 0, len = coparentPhones.length; i < len; i++) {
      phone = coparentPhones[i];
      subId = (await NotificationManager.getUserSubId(phone));
      results.push((await NotificationManager.sendNotification(title, message, subId)));
    }
    return results;
  }
};

//# sourceMappingURL=notificationManager.js.map
